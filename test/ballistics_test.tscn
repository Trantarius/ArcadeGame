[gd_scene load_steps=4 format=3 uid="uid://1ou2bpdp2log"]

[sub_resource type="GDScript" id="GDScript_sewsl"]
script/source = "@tool
extends Node2D

var points:Array[Vector2]
var thrusts:Array[Vector2]
var endpoints:Array[Vector2]

var startpos:Vector2
var velpos:Vector2
var vel_enabled:bool
var accpos:Vector2
var acc_enabled:bool

var endpos:Vector2
var endvelpos:Vector2
var endvel_enabled:bool
var endaccpos:Vector2
var endacc_enabled:bool

@export var timestep:float = 0.1:
	set(to):
		timestep=to
		update()
		queue_redraw()
@export var duration:float = 5:
	set(to):
		duration=to
		update()
		queue_redraw()
@export_range(0,1) var brake:float = 1:
	set(to):
		brake=to
		update()
		queue_redraw()

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(_delta: float) -> void:
	var changed:bool = false
	if(global_position!=startpos):
		startpos=global_position
		changed=true
	if($Vel.global_position!=velpos):
		velpos=$Vel.global_position
		changed=true
	if($Vel.visible!=vel_enabled):
		vel_enabled=$Vel.visible
		changed=true
	if($Acc.global_position!=accpos):
		accpos=$Acc.global_position
		changed=true
	if($Acc.visible!=acc_enabled):
		acc_enabled=$Acc.visible
		changed=true
	if($End.global_position!=endpos):
		endpos=$End.global_position
		changed=true
	if($EndVel.global_position!=endvelpos):
		endvelpos=$EndVel.global_position
		changed=true
	if($EndVel.visible!=endvel_enabled):
		endvel_enabled=$EndVel.visible
		changed=true
	if($EndAcc.global_position!=endaccpos):
		endaccpos=$EndAcc.global_position
		changed=true
	if($EndAcc.visible!=endacc_enabled):
		endacc_enabled=$EndAcc.visible
		changed=true
	if(changed):
		update()
		queue_redraw()

func update()->void:
	points = [startpos]
	endpoints = [endpos]
	thrusts = []
	var time:float = 0
	var velocity:Vector2 = velpos-startpos if vel_enabled else Vector2.ZERO
	var acceleration:Vector2 = accpos-startpos if acc_enabled else Vector2.ZERO
	var end_velocity:Vector2 = endvelpos - endpos if endvel_enabled else Vector2.ZERO
	var end_acceleration:Vector2 = endaccpos - endpos if endacc_enabled else Vector2.ZERO
	while(time<duration):
		var thrust:Vector2 = Ballistics.find_thrust_to_position(points.back(), velocity, acceleration, 
			endpoints.back(), end_velocity, end_acceleration, 100, brake)
		thrusts.push_back(thrust)
		velocity += (thrust + acceleration) * timestep
		points.push_back(points.back() + velocity*timestep)
		end_velocity += end_acceleration * timestep
		endpoints.push_back(endpoints.back() + end_velocity*timestep)
		time+=timestep
	thrusts.push_back(Vector2.ZERO)# just to match sizes

func _draw() -> void:
	
	for n:int in range(points.size()):
		draw_circle(points[n]-global_position,2 if n%10==0 else 1,Color.WHITE)
		draw_circle(endpoints[n]-global_position,2 if n%10==0 else 1,Color.RED)
		draw_line(points[n]-global_position, points[n]-global_position + thrusts[n]/20, Color.GREEN)
		if(n%10==0):
			draw_line(points[n]-global_position, endpoints[n]-global_position, Color.BLUE)
	
"

[sub_resource type="GDScript" id="GDScript_v7sbi"]
script/source = "@tool
extends Node2D

@export var timestep:float = 0.1:
	set(to):
		timestep=to
		update()
		queue_redraw()
@export var duration:float = 5:
	set(to):
		duration=to
		update()
		queue_redraw()
@export var proj_speed:float = 100:
	set(to):
		proj_speed=to
		update()
		queue_redraw()

var pos:Vector2
var tpos:Vector2
var tvelpos:Vector2

var points:Array[Vector2]
var tpoints:Array[Vector2]
var hit:Vector2

# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(_delta: float) -> void:
	var changed:bool = false
	if(global_position!=pos):
		pos=global_position
		changed=true
	if($Target.global_position!=tpos):
		tpos=$Target.global_position
		changed=true
	if($TargetVel.global_position!=tvelpos):
		tvelpos=$TargetVel.global_position
		changed=true
	if(changed):
		update()
		queue_redraw()

func update()->void:
	points = [pos]
	tpoints = [tpos]
	var time:float = 0
	var tvel:Vector2 = (tvelpos - tpos).limit_length(proj_speed*0.95)
	var intercept:Dictionary = Ballistics.solve_linear_intercept(proj_speed, tpos-pos, tvel)
	hit = intercept.intercept
	while(time<duration):
		points.push_back(points.back() + intercept.velocity*timestep)
		tpoints.push_back(tpoints.back() + tvel*timestep)
		time+=timestep

func _draw() -> void:
	
	for n:int in range(points.size()):
		draw_circle(points[n]-global_position,2 if n%10==0 else 1,Color.WHITE)
		draw_circle(tpoints[n]-global_position,2 if n%10==0 else 1,Color.RED)
		if(n%10==0):
			draw_line(points[n]-global_position, tpoints[n]-global_position, Color.BLUE)
	
	if(hit.is_finite()):
		draw_circle(hit, 3, Color.GREEN)
	
"

[sub_resource type="GDScript" id="GDScript_nah1q"]
script/source = "@tool
extends Node2D

var pos:Vector2
var capos:Vector2
var dapos:Vector2
var cvpos:Vector2

# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(_delta: float) -> void:
	if(global_position != pos):
		pos = global_position
		queue_redraw()
	if($CurrentAngle.position != capos):
		capos = $CurrentAngle.position
		queue_redraw()
	if($DesiredAngle.position != dapos):
		dapos = $DesiredAngle.position
		queue_redraw()
	if($CurrentVelocity.position != cvpos):
		cvpos = $CurrentVelocity.position
		queue_redraw()
		

func _draw()->void:
	
	var curr_theta:float = capos.angle()
	var targ_theta:float = dapos.angle()
	var curr_vel:float = cvpos.angle() - curr_theta
	var max_torque:float = 1
	var torque:float
	
	var brake_time:float = abs(curr_vel) / max_torque
	var brake_drift:float = curr_vel*brake_time/2
	if(brake_drift>TAU):
		torque = -sign(curr_vel)*max_torque
	else:
		var anticipated_position:float = curr_theta + brake_drift
		draw_line(Vector2.ZERO, Vector2.from_angle(anticipated_position) * capos.length(), Color(1,1,0))
		torque = sign(angle_difference(anticipated_position,targ_theta))*max_torque
	
	draw_line(Vector2.ZERO, capos, Color(0,0,1))
	draw_line(Vector2.ZERO, dapos, Color(0,1,1))
	
	draw_arc(Vector2.ZERO, 50, curr_theta, curr_vel+curr_theta, 64, Color(1,0,0))
	draw_arc(Vector2.ZERO, 60, curr_theta, torque+curr_theta, 64, Color(0,1,0))"

[node name="BallisticsTest" type="Node"]

[node name="Trajectory" type="Node2D" parent="."]
position = Vector2(428, 129)
script = SubResource("GDScript_sewsl")
duration = 10.0
brake = 0.0

[node name="Vel" type="Marker2D" parent="Trajectory"]
position = Vector2(99, 101)

[node name="Acc" type="Marker2D" parent="Trajectory"]
visible = false
position = Vector2(110, 108)

[node name="End" type="Marker2D" parent="Trajectory"]
position = Vector2(218, -27)

[node name="EndVel" type="Marker2D" parent="Trajectory"]
position = Vector2(312, 43)

[node name="EndAcc" type="Marker2D" parent="Trajectory"]
position = Vector2(192, -28)

[node name="LinearShot" type="Node2D" parent="."]
position = Vector2(40, 192)
script = SubResource("GDScript_v7sbi")

[node name="Target" type="Marker2D" parent="LinearShot"]
position = Vector2(0, 328)

[node name="TargetVel" type="Marker2D" parent="LinearShot"]
position = Vector2(68, 292)

[node name="Torque" type="Node2D" parent="."]
script = SubResource("GDScript_nah1q")

[node name="CurrentAngle" type="Marker2D" parent="Torque"]
position = Vector2(125, -14)

[node name="DesiredAngle" type="Marker2D" parent="Torque"]
position = Vector2(159, 47)

[node name="CurrentVelocity" type="Marker2D" parent="Torque"]
position = Vector2(53, 92)
